# SOCKS Proxy via Unix Domain Socket - Implementation Research

## Summary

A SOCKS5 proxy listening on a unix domain socket can provide network filtering for the sandbox **even with `--unshare-net`** network isolation, because unix domain sockets are filesystem objects that work across network namespaces.

## Key Technical Findings

### 1. Unix Sockets Work Across Network Namespaces

- Network namespaces isolate: network devices, IP stacks, routing tables, sockets
- **Exception**: Unix domain sockets (filesystem-based) are NOT isolated by network namespaces
- This allows communication between isolated sandbox and host proxy

### 2. SOCKS Proxy Implementations with Unix Socket Support

**Recommended: pproxy (Python)**
- PyPI package: `pproxy`
- Supports listening on unix domain sockets
- Built-in domain filtering with regex
- Pure Python, easy integration
- Command: `pproxy -l socks5://user:pass@/tmp/proxy.sock`

**Alternative: soxidizer (Rust)**
- Purpose-built for SOCKS5 over unix sockets
- Directory-based filtering
- Better performance but harder to integrate

### 3. Application Support

**Native unix socket SOCKS support:**
- curl (v7.84.0+): `curl --proxy socks5h://localhost/tmp/proxy.sock https://example.com`
- Firefox/FoxyProxy

**Applications needing bridge:**
- Most applications expect host:port format
- Solution: Use `socat` to bridge unix socket → TCP localhost
- Then set `ALL_PROXY=socks5://127.0.0.1:1080`

```bash
socat TCP-LISTEN:1080,bind=127.0.0.1,reuseaddr,fork UNIX-CONNECT:/tmp/proxy.sock &
export ALL_PROXY="socks5://127.0.0.1:1080"
```

## Proposed Architecture

```
Host (has network):
  └─ socks_filter.py (pproxy daemon)
      └─ Listens on /tmp/bw-claude-SESSION.sock
      └─ Whitelist: *.anthropic.com, *.claude.ai
      └─ Forwards allowed → real network
      └─ Blocks/logs denied connections

Unix Socket: /tmp/bw-claude-SESSION.sock
  └─ Bind mounted into sandbox

Sandbox (--unshare-net, no network):
  └─ Socket available at /proxy.sock
  └─ socat bridges /proxy.sock → 127.0.0.1:1080
  └─ ALL_PROXY=socks5://127.0.0.1:1080
  └─ Applications use proxy → controlled network access
```

## Approved Implementation Plan (Phase-Based Architecture)

### Executive Summary

**Two-layer proxy architecture**:
- **Outside (host)**: bwrap-proxy library embedded in bw-claude/bw-gemini, listens on UDS, enforces policies
- **Inside (sandbox)**: bw-relay binary, provides localhost SOCKS5/HTTP proxy, converts HTTP→SOCKS5, forwards over UDS
- **Communication**: Pass-through SOCKS5 protocol over Unix domain socket
- **Startup**: Shell script generated by bwrap-core, starts bw-relay + sets env vars + execs target

### Config file
- We need a config file which covers the same scope as the command-line options
- Use TOML, with appropriate sections for common, claude, gemini, which can be
  extended to other llms as needed
- We should support multiple config files, from highest to lowest priority:
  - CLI argument (`--proxy-config <file>`)
  - Environment variable (`$BW_CLAUDE_CONFIG`)
  - User config (`~/.config/bw-claude/config.toml`)
  - Default/builtin
- Relative paths in config files are relative to the project dir or home

### Outside Proxy (bwrap-proxy - embedded in frontends)
- Rust library embedded in bw-claude/bw-gemini processes
- Listens on Unix domain socket (created in /tmp by frontend)
- Implements SOCKS5 server protocol
- PolicyEngine evaluates connections against configured policies
- LearningRecorder records accessed domains in learning mode
- Spawned as separate process before sandbox execution
- Operates in 3 modes:
  1. **open** - allows all traffic
  2. **learning** - allows all, records accessed hosts/IPs to TOML for later review
  3. **restrictive:<policy>** - enforces named policy from config
- Network config section contains:
  - Named groups of hosts/IP ranges (e.g., "anthropic", "github")
  - Hostnames support wildcard patterns
  - IPv4/IPv6 CIDR ranges supported
  - Groups can reference other groups (with cycle detection)
  - Policies are collections of groups
  - Groups/policies validated at startup

### Inside Proxy (bw-relay - new binary crate)
- Minimal standalone binary running inside sandbox
- Listens on localhost:1080 (SOCKS5) and localhost:3128 (HTTP CONNECT)
- **SOCKS5 server** (port 1080):
  - Accepts SOCKS5 client connections
  - Forwards raw SOCKS5 protocol bytes over UDS to outside proxy
  - Relays traffic bidirectionally
- **HTTP CONNECT server** (port 3128):
  - Parses HTTP CONNECT requests for HTTPS tunneling
  - Converts CONNECT requests to SOCKS5 format
  - Forwards as SOCKS5 to outside proxy
  - Returns HTTP/1.1 200 response to client
  - Relays HTTPS traffic bidirectionally
- Started by generated startup script
- Communicates with outside proxy exclusively via UDS
- No policy logic - just relays

### Startup Mechanism
- bwrap-core generates shell script that runs inside container
- Script:
  1. Starts bw-relay in background
  2. Waits for relay ports to be ready (nc check)
  3. Sets HTTP_PROXY, HTTPS_PROXY, ALL_PROXY env vars pointing to localhost
  4. Execs target binary (Claude/Gemini)
  5. Cleanup: kills relay on exit via trap handler
- Script is mounted read-only from host

## Implementation Phases

### Phase 1: Complete bwrap-proxy SOCKS5 Server (1-2 days)
- Add TCP connection forwarding to `server.rs` (line 147 TODO)
- Implement `.into_inner()` socket extraction from fast-socks5
- Create `main.rs` binary entry point with CLI args (--socket, --mode, --config)
- Update Cargo.toml with [[bin]] target

### Phase 2: Create bw-relay Crate (2-3 days)
- New crate: `bw-relay/` with minimal dependencies
- SOCKS5 pass-through server (port 1080) → forwards to UDS
- HTTP CONNECT converter (port 3128) → converts to SOCKS5 → forwards to UDS
- Dependencies: tokio-socks, hyper, http-body-util
- Single main.rs with async runtime

### Phase 3: bwrap-core Integration (2-3 days)
- Create `startup_script.rs` for shell script generation
- Implement NetworkMode::Filtered handling (line 266 TODO)
- Mount proxy socket and bw-relay binary into sandbox
- Generate and mount startup script
- Change command execution to run script instead of direct binary

### Phase 4: Frontend Integration (2-3 days)
- Make bw-claude/bw-gemini main async with tokio
- Add CLI args: --proxy, --proxy-mode, --proxy-config
- Spawn proxy daemon before sandbox execution
- ProxyDaemon lifecycle management with Drop impl
- Wait for socket creation before proceeding
- Dependencies: tokio::process, bwrap-proxy library

### Phase 5: Testing & Documentation (2-3 days)
- Configuration file examples
- Integration testing with curl
- Learning mode testing
- Policy enforcement testing
- Documentation update

---

## Detailed Implementation Plan (Reference)

### 1. Complete TOML Configuration Schema

**Config file location: `~/.config/bw-claude/config.toml`**

```toml
[common]
config_version = "1.0"
verbose = false

[common.proxy]
default_mode = "restrictive"
socket_dir = "/tmp"
learning_output = "~/.config/bw-claude/learned-domains.toml"

# Network configuration - host groups
[network.groups.anthropic]
description = "Anthropic API endpoints"
hosts = ["*.anthropic.com", "*.claude.ai", "api.anthropic.com"]
ipv4_ranges = []
ipv6_ranges = []

[network.groups.googlesearch]
description = "Google Search and related services"
hosts = ["*.google.com", "*.googleapis.com", "*.gstatic.com"]
ipv4_ranges = ["142.250.0.0/15"]

[network.groups.common_tools]
description = "Common development tools"
hosts = ["*.github.com", "*.npmjs.org", "*.crates.io"]

# Policies are collections of named groups
[network.policies.claude_default]
description = "Default restrictive policy for Claude"
groups = ["anthropic", "googlesearch", "common_tools"]

[network.policies.open]
description = "Allow all traffic"
groups = []
allow_all = true

# Tool-specific configurations
[claude]
enabled = true
proxy_mode = "restrictive:claude_default"

[gemini]
enabled = true
proxy_mode = "restrictive:gemini_default"
```

### 2. Rust Crate Dependencies

Add to workspace `Cargo.toml`:

```toml
[workspace.dependencies]
# SOCKS5 proxy
fast-socks5 = "0.9"

# Network filtering
ipnet = "2.10"           # IP/CIDR matching
wildmatch = "2.3"        # Wildcard domain matching

# Configuration
toml = "0.8"
serde = { version = "1.0", features = ["derive"] }
```

**Rationale:**
- **fast-socks5**: Most actively maintained SOCKS5 library, 53K+ downloads/month
- **ipnet**: Comprehensive CIDR/subnet operations
- **wildmatch**: Efficient wildcard domain matching

### 3. Module Structure for `bwrap-proxy`

```
bwrap-proxy/
├── src/
│   ├── main.rs              # CLI entry point
│   ├── lib.rs               # Library exports
│   ├── config/
│   │   ├── mod.rs           # Config module
│   │   ├── schema.rs        # TOML schema types
│   │   ├── loader.rs        # Config file loading/merging
│   │   └── validator.rs     # Cycle detection, validation
│   ├── filter/
│   │   ├── mod.rs           # Filter module
│   │   ├── policy.rs        # Policy resolution and evaluation
│   │   ├── matcher.rs       # Host/IP matching logic
│   │   └── learning.rs      # Learning mode recorder
│   ├── proxy/
│   │   ├── mod.rs           # Proxy module
│   │   ├── server.rs        # SOCKS5 server implementation
│   │   ├── handler.rs       # Connection handler
│   │   └── socket.rs        # Unix domain socket management
│   ├── bridge.rs            # Native TCP-to-Unix bridge (no socat)
│   └── error.rs             # Error types
└── tests/
    ├── config_tests.rs
    └── filter_tests.rs
```

### 4. Key Implementation Components

#### Config Schema Types

```rust
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Config {
    pub common: CommonConfig,
    pub network: NetworkConfig,
    pub claude: Option<ToolConfig>,
    pub gemini: Option<ToolConfig>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct NetworkConfig {
    pub groups: HashMap<String, HostGroup>,
    pub policies: HashMap<String, Policy>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct HostGroup {
    pub description: String,
    pub hosts: Vec<String>,          // Wildcarded hostnames
    pub ipv4_ranges: Vec<String>,    // CIDR notation
    pub ipv6_ranges: Vec<String>,
    pub groups: Vec<String>,         // References to other groups
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Policy {
    pub description: String,
    pub groups: Vec<String>,
    pub allow_all: bool,
}
```

#### Cycle Detection in Group References

```rust
pub fn check_cycles(network: &NetworkConfig) -> Result<(), ValidationError> {
    for (group_name, _) in &network.groups {
        let mut visited = HashSet::new();
        let mut path = Vec::new();
        dfs_cycle_check(group_name, &network.groups, &mut visited, &mut path)?;
    }
    Ok(())
}

fn dfs_cycle_check(
    group_name: &str,
    groups: &HashMap<String, HostGroup>,
    visited: &mut HashSet<String>,
    path: &mut Vec<String>,
) -> Result<(), ValidationError> {
    if path.contains(&group_name.to_string()) {
        path.push(group_name.to_string());
        return Err(ValidationError::CycleDetected {
            path: path.join(" -> "),
        });
    }
    // ... recursively check child groups
}
```

#### Policy Matcher with Wildcards and IP Ranges

```rust
pub struct HostMatcher {
    patterns: Vec<WildMatch>,       // Wildcard domain patterns
    ipv4_ranges: Vec<Ipv4Net>,      // IPv4 CIDR ranges
    ipv6_ranges: Vec<Ipv6Net>,      // IPv6 CIDR ranges
}

impl HostMatcher {
    pub fn matches_host(&self, host: &str) -> bool {
        self.patterns.iter().any(|p| p.matches(host))
    }

    pub fn matches_ip(&self, ip: IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_ranges.iter().any(|net| net.contains(&ipv4)),
            IpAddr::V6(ipv6) => self.ipv6_ranges.iter().any(|net| net.contains(&ipv6)),
        }
    }
}
```

#### Learning Mode Recorder

```rust
pub struct LearningRecorder {
    hosts: Arc<Mutex<HashSet<String>>>,
}

impl LearningRecorder {
    pub fn record(&self, host: &str, ip: Option<IpAddr>) {
        let mut hosts = self.hosts.lock().unwrap();
        hosts.insert(host.to_string());
    }

    pub fn save_to_toml(&self, path: &Path) -> std::io::Result<()> {
        // Generate TOML with learned domains
        // Format: [network.groups.learned_session_TIMESTAMP]
    }
}
```

#### Native TCP-to-Unix Bridge (replaces socat)

```rust
pub async fn run_bridge(bind_addr: &str, unix_socket: &str) -> anyhow::Result<()> {
    let listener = TcpListener::bind(bind_addr).await?;

    loop {
        let (mut tcp_stream, _) = listener.accept().await?;
        let unix_socket = unix_socket.to_string();

        tokio::spawn(async move {
            let mut unix_stream = UnixStream::connect(&unix_socket).await?;
            // Bidirectional copy between TCP and Unix streams
            tokio::io::copy_bidirectional(&mut tcp_stream, &mut unix_stream).await
        });
    }
}
```

### 5. Integration with bwrap-core

#### Update NetworkMode

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum NetworkMode {
    Enabled,
    Disabled,
    Filtered {
        policy_name: String,
        proxy_socket: PathBuf,
    },
}
```

#### Proxy Daemon Lifecycle

```rust
pub struct ProxyDaemon {
    child: Child,
    socket_path: PathBuf,
}

impl ProxyDaemon {
    pub fn spawn(policy_name: &str, socket_path: PathBuf) -> Result<Self> {
        let mut cmd = Command::new("bwrap-proxy");
        cmd.arg("--policy").arg(policy_name);
        cmd.arg("--socket").arg(&socket_path);

        let child = cmd.spawn()?;

        // Wait for socket to be created
        for _ in 0..50 {
            if socket_path.exists() { break; }
            std::thread::sleep(Duration::from_millis(10));
        }

        Ok(Self { child, socket_path })
    }
}

impl Drop for ProxyDaemon {
    fn drop(&mut self) {
        let _ = self.child.kill();
        let _ = std::fs::remove_file(&self.socket_path);
    }
}
```

#### Mount Socket in Sandbox

```rust
// In SandboxBuilder::setup_mounts()
if let NetworkMode::Filtered { ref proxy_socket, .. } = self.config.network_mode {
    self.mounts.push(MountPoint::rw(proxy_socket, &PathBuf::from("/proxy.sock")));
}
```

### 6. CLI Integration

#### bw-claude flags

```rust
#[derive(Parser)]
struct Args {
    /// Enable network filtering via SOCKS5 proxy
    #[arg(long)]
    proxy: bool,

    /// Proxy mode: open | learning | restrictive:<policy>
    #[arg(long, requires = "proxy")]
    proxy_mode: Option<String>,

    /// Custom proxy config file
    #[arg(long)]
    proxy_config: Option<PathBuf>,
}
```

#### bwrap-proxy binary

```rust
#[derive(Parser)]
struct Args {
    /// SOCKS5 socket path
    #[arg(long, short = 's')]
    socket: PathBuf,

    /// Proxy mode: open, learning, restrictive:<policy>
    #[arg(long, short = 'm')]
    mode: String,

    /// Config file path
    #[arg(long, short = 'c')]
    config: Option<PathBuf>,

    /// Run TCP bridge on 127.0.0.1:1080
    #[arg(long)]
    bridge: bool,
}
```

### 7. Implementation Order

**Phase 1: Configuration Foundation (Week 1)**
1. Config schema types (`config/schema.rs`)
2. Config loader with defaults (`config/loader.rs`)
3. Validator with cycle detection (`config/validator.rs`)
4. Unit tests for config validation
5. Example config files

**Phase 2: Filtering Engine (Week 1-2)**
6. HostMatcher with wildcards (`filter/matcher.rs`)
7. PolicyEngine with group resolution (`filter/policy.rs`)
8. LearningRecorder (`filter/learning.rs`)
9. Unit tests for filtering logic

**Phase 3: SOCKS5 Proxy (Week 2-3)**
10. SOCKS5 server with unix socket (`proxy/server.rs`)
11. Connection handler with filtering (`proxy/handler.rs`)
12. Integration with PolicyEngine and LearningRecorder
13. Basic functionality testing with curl

**Phase 4: Bridge & Integration (Week 3-4)**
14. Native Rust TCP-to-Unix bridge (`bridge.rs`)
15. ProxyDaemon lifecycle management
16. Update SandboxBuilder for socket mounting
17. Update CLI binaries with proxy flags
18. End-to-end integration testing

**Phase 5: Polish (Week 4-5)**
19. Comprehensive error handling
20. Documentation and examples
21. Performance testing
22. Release v0.1.0

### 8. Testing Strategy

- **Unit tests**: Config validation, cycle detection, wildcard matching, IP ranges
- **Integration tests**: Proxy + filter + real SOCKS5 clients
- **Real-world tests**: Claude with restrictive policy, learning mode
- **Security tests**: Verify denied connections are blocked

### 9. Expected Behavior

**With `--proxy --proxy-mode restrictive:claude_default`:**
1. Start proxy daemon on unix socket
2. Mount socket into sandbox with `--unshare-net`
3. Set `ALL_PROXY=socks5://127.0.0.1:1080`
4. Only allow connections matching policy
5. Log denied connection attempts
6. Clean up socket on exit

**With `--proxy --proxy-mode learning`:**
1. Allow all connections
2. Record accessed domains
3. Save to TOML file on exit
4. User reviews and creates policy

## References

- pproxy: https://pypi.org/project/pproxy/
- soxidizer: https://github.com/randomstuff/soxidizer
- curl SOCKS: https://everything.curl.dev/usingcurl/proxies/socks.html
- Network namespaces: https://man7.org/linux/man-pages/man7/network_namespaces.7.html
- Unix sockets across namespaces: https://lwn.net/Articles/580893/
- fast-socks5: https://github.com/dizda/fast-socks5
- ipnet: https://docs.rs/ipnet/
- wildmatch: https://crates.io/crates/wildmatch
